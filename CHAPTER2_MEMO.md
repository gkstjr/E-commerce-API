# 3주간의 서버 구축 과제 회고

이번 3주간의 서버 구축 과제를 진행하며 이전에도 많이 해봤던 (E-commerce) 토이 프로젝트를 진행하는 것임에도 아는 만큼 보이고 요구사항 분석이 깔끔해지는 느낌을 받았습니다. 큰 도움이 되었던 3주 동안 느꼈던 점들을 프로젝트의 순서대로 세분화하여 정리한 글입니다.

## 1. 도메인 선정
도메인 선정은 E-commerce로 진행했습니다. 이유는 주문, 결제, 상품, 사용자, 관리자와 같은 기능들이 다른 도메인에서도 공통으로 사용되는 부분들이 많다고 생각해서 선택하게 되었습니다.

## 2. 요구사항 분석
- 항해 교육 이전에는 요구사항을 보고 성공하는 상황만 생각하고 코드 작성을 진행했는데, 이번 과제에서는 요구사항별 실패 케이스를 세분화하고 성공 케이스를 정리하는 순서로 진행했습니다.  
  **(실패 케이스의 세분화는 입력값에 대한 실패, 정책에 의한 실패와 같이 정리)**
- 위와 같은 방식으로 진행해보니 분석 단계에서의 시간 소모가 늘어나지만 설계에서는 자세한 엔티티의 연관관계, 필드들에 대한 정리가 수월해졌습니다.  
  또한, 테스트 코드 작성 시에도 테스트 시나리오를 요구사항 분석대로 정하면 되므로 전체적인 개발 속도가 크게 올라갔다는 느낌을 받았습니다.

## 3. 설계
### 3.1 ERD, 시퀀스 다이어그램
- ERD 작성에서는 Entity의 연관관계에 대해서 고민하며 진행했습니다. `BaseEntity`를 이용하여 생성, 수정 시간 등의 공통 필드를 분리했습니다. 요구사항 분석에 따라 큰 형태의 테이블의 필드를 정하고 추후 개발을 진행하며 수정하는 방식으로 진행했습니다.
- 시퀀스 다이어그램을 작성하며 기능마다 어떠한 순서로 비즈니스 로직이 진행되는지 파악하는 데 큰 도움이 되었습니다. 이번에는 각 레이어별로 구분해서 작성했지만 다이어그램을 보는 사람에 따라 변경이 필요하다고 생각이 들었습니다.

### 3.2 패키지 구조
- 주로 계층형 아키텍처를 기반으로 설계했지만, 이번 과제에서는 항해에서 배운 클린 + Layer 아키텍처로 진행했습니다.

  이 아키텍처는 데이터 계층 및 API 계층이 비즈니스 로직(도메인)을 의존하여 도메인 중심적이며 DIP, OCP를 만족하는 계층 아키텍처입니다.

- 패키지 구조는 도메인 중심 구조로 구성하였습니다.
    - 가독성과 유지보수가 쉬움.
    - 도메인 모델에 집중하는 클린 + Layer 아키텍처에 적합.
    - 프로젝트의 규모가 커질수록 효율적.

- 과제 패키지 구성:
    ```plaintext
    └─hhplus
        └─ecommerce
            ├─common
            │  └─exception
            ├─coupon
            │  ├─application
            │  ├─domain
            │  │  ├─dto
            │  │  ├─issuedcoupon
            │  │  └─model
            │  ├─infra
            │  │  └─issuedCoupon
            │  └─interfaces
            ├─order
            │  ├─application
            │  │  ├─dataplatform
            │  │  └─dto
            │  ├─domain
            │  │  ├─dto
            │  │  └─model
            │  ├─infra
            │  └─interfaces
            ├─payment
            │  ├─application
            │  ├─domain
            │  │  ├─dto
            │  │  └─model
            │  ├─infra
            │  └─interfaces
            ├─point
            │  ├─application
            │  ├─domain
            │  │  ├─dto
            │  │  └─model
            │  ├─infra
            │  └─interfaces
            ├─product
            │  ├─application
            │  ├─domain
            │  │  ├─dto
            │  │  ├─model
            │  │  └─stock
            │  ├─infra
            │  │  └─stock
            │  └─interfaces
            └─user
                ├─application
                ├─domain
                │  └─model
                ├─infra
                └─interfaces
    ```

## 4. 구현
1. 테스트 코드 작성
2. 구현 코드 작성
3. 리팩토링

- 위와 같은 순서로 개발을 진행해보니 처음에는 의미 없이 개발 시간이 늘어나는 게 아닐까?라는 걱정을 했었지만, 일정한 반복과 숙달에 의해 어느 순간부터는 시간적으로 테스트 코드 없이 개발하는 방법과 크게 차이를 느끼지 못했습니다.
- 무엇보다 현재 저의 개발 진행 사항을 작성된 테스트 코드들을 보며 파악하기 훨씬 수월하게 느껴졌고, 작성한 코드의 잘못된 부분들을 잡아내기가 좋았습니다.
- 또한, 테스트 코드의 순서를 실패 케이스 → 성공 케이스로 작성하다 보니 해당 케이스 별로 구현 코드 작성이 세분화되어 진행되었고, 기능을 구현하는 데도 코드 수정에 쓰는 시간을 많이 줄여준다고 느껴졌습니다.

## 5. API Swagger 명세서
- 외부 API 호출자가 요청과 응답 흐름을 확인할 수 있고, 개발 초기 단계에 클라이언트 개발을 시작할 수 있게 가상 데이터를 제공해줌으로써 유용한 방법이라고 느꼈습니다.

## 6. 기타
- 파사드 패턴을 활용하여 주문과 결제 API를 하나의 유즈케이스로 묶고, 이를 사용자에게 제공하는 방식으로 설계해 보았습니다.  
  이 과정에서 유즈케이스의 추가나 변경에 따라 여러 서비스 로직을 자유롭게 조합하여 활용할 수 있음을 깨달았습니다.  
  이를 통해 "**유지보수성과 재사용성을 크게 향상시킬 수 있겠구나**"라는 생각을 하게 되었습니다.  
  이 과정에서 트랜잭션 설정에 대해 깊이 고민하고 신중하게 결정해야 합니다.
